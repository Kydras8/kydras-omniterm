#!/usr/bin/env zsh
set -euo pipefail
setopt NO_BANG_HIST
emulate -L zsh

usage() {
  cat <<'H'
omniterm — tmux session manager with profiles + themes

Usage:
  omniterm start [-d|--detached] [--session NAME] [--profile NAME] [--theme NAME]
  omniterm attach [SESSION]
  omniterm list
  omniterm kill [SESSION]
  omniterm new [:lang] [title]
  omniterm run [:lang] 'code'
  omniterm theme NAME
  omniterm doctor
  omniterm self-update [REPO_PATH]
  omniterm snapshot [SESSION] [NAME]
  omniterm restore  [SESSION] [NAME]
H
}

ensure_tmux(){ command -v tmux >/dev/null || { print -u2 "[-] tmux not found. sudo apt install -y tmux"; exit 127; }; }
session_exists(){ tmux has-session -t "$1" 2>/dev/null }
is_tty(){ [[ -t 1 ]] }

# --- theme support ---
apply_theme() {
  local s="$1" name="${2:-}"
  [[ -z "$name" ]] && return 0
  local f="" cfg="$HOME/.config/omniterm/theme-${name}.tmux" \
        share="$HOME/.local/share/omniterm/themes/theme-${name}.tmux" \
        here="$0:A:h:h/themes/theme-${name}.tmux"
  if   [[ -r "$cfg"  ]]; then f="$cfg"
  elif [[ -r "$share" ]]; then f="$share"
  elif [[ -r "$here" ]];  then f="$here"
  fi
  [[ -n "$f" ]] && tmux source-file "$f" || print -u2 "[omniterm] theme not found: $name"
  tmux set-environment -g OMNITERM_ZSH_THEME "$name" 2>/dev/null || true
}

# --- extras: doctor / self-update / snapshot ---
doctor() {
  echo "[doctor] zsh:    $(zsh --version 2>/dev/null || echo missing)"
  echo "[doctor] tmux:   $(tmux -V 2>/dev/null || echo missing)"
  for x in node python3 gcc docker podman firejail inotifywait unzip rsync; do
    if command -v "$x" >/dev/null 2>&1; then
      echo "[doctor] $x:    $($x --version 2>&1 | head -n1)"
    else
      echo "[doctor] $x:    missing"
    fi
  done
  command -v poly >/dev/null 2>&1 || echo "[doctor] poly not on PATH"
}

self_update() {
  local repo="${1:-$HOME/kydras-omniterm}"
  if [[ -d "$repo/.git" ]]; then
    echo "[self-update] $repo"
    (cd "$repo" && git pull --ff-only && ./install.sh)
    echo "[self-update] done."
  elif command -v gh >/dev/null 2>&1; then
    echo "[self-update] using gh latest release"
    local tmp; tmp="$(mktemp -d)"; pushd "$tmp" >/dev/null
    gh release download -R Kydras8/kydras-omniterm -p 'kydras-omniterm-v*.zip' -O latest.zip
    unzip -q latest.zip
    rsync -av kydras-omniterm/ "$HOME/kydras-omniterm/"
    "$HOME/kydras-omniterm/install.sh"
    popd >/dev/null; rm -rf "$tmp"
    echo "[self-update] done."
  else
    echo "[-] provide repo path or install GitHub CLI (gh)" >&2
    return 2
  fi
}

snapshot_save() {
  local s="${1:-${OMNITERM_SESSION:-k-omni}}"
  local name="${2:-default}"
  local dir="${XDG_CONFIG_HOME:-$HOME/.config}/omniterm/snapshots"
  mkdir -p "$dir"
  local out="$dir/${s}-${name}.tmux"
  {
    echo "# snapshot for session $s @ $(date -Is)"
    echo "new-session -d -s \"$s\" -n zsh zsh -l"
    tmux list-windows -t "$s" -F "rename-window -t \"$s:#{window_index}\" \"#{window_name}\"" || true
    tmux list-windows -t "$s" -F "#{window_index} #{window_layout}" | while read -r idx layout; do
      echo "select-window -t \"$s:$idx\""
      echo "select-layout -t \"$s:$idx\" $layout"
    done
  } > "$out"
  echo "[snapshot] saved -> $out"
}

snapshot_restore() {
  local s="${1:-${OMNITERM_SESSION:-k-omni}}"
  local name="${2:-default}"
  local dir="${XDG_CONFIG_HOME:-$HOME/.config}/omniterm/snapshots"
  local file="$dir/${s}-${name}.tmux"
  [[ -r "$file" ]] || { echo "[-] snapshot not found: $file" >&2; return 2; }
  tmux has-session -t "$s" 2>/dev/null || tmux new-session -d -s "$s" -n zsh zsh -l
  tmux source-file "$file"
  echo "[snapshot] restored from $file"
}

# --- defaults ---
SESSION="${OMNITERM_SESSION:-k-omni}"
PROFILE="${OMNITERM_PROFILE:-default}"
THEME="${OMNITERM_THEME:-}"

cmd="${1:-}"
[[ -z "$cmd" || "$cmd" == "-h" || "$cmd" == "--help" ]] && { usage; exit 0; }
ensure_tmux; shift || true

case "$cmd" in
  start)
    det=0
    while [[ "${1:-}" == -* ]]; do
      case "$1" in
        -d|--detached) det=1 ;;
        --session) shift; SESSION="${1:-$SESSION}" ;;
        --session=*) SESSION="${1#--session=}" ;;
        --profile) shift; PROFILE="${1:-$PROFILE}" ;;
        --profile=*) PROFILE="${1#--profile=}" ;;
        --theme) shift; THEME="${1:-$THEME}" ;;
        --theme=*) THEME="${1#--theme=}" ;;
        *) print -u2 "Unknown flag: $1"; usage; exit 2 ;;
      esac; shift || true
    done
    [[ -n "${1:-}" ]] && SESSION="$1"

    if session_exists "$SESSION"; then
      apply_theme "$SESSION" "$THEME"
      (( det || ! is_tty )) && { echo "[omniterm] session '$SESSION' already running (detached)"; exit 0; }
      exec tmux attach -t "$SESSION"
    fi

    tmux new-session -d -s "$SESSION" -n "zsh" zsh -l
    cfg="${XDG_CONFIG_HOME:-$HOME/.config}/omniterm/profile-${PROFILE}.zsh"
    if [[ -r "$cfg" ]]; then source "$cfg"; typeset -f omniterm_profile >/dev/null 2>&1 && omniterm_profile "$SESSION"; fi
    apply_theme "$SESSION" "$THEME"
    (( det || ! is_tty )) && { echo "[omniterm] started session '$SESSION' (detached)"; exit 0; }
    exec tmux attach -t "$SESSION"
    ;;
  attach)
    SESSION="${1:-$SESSION}"; exec tmux attach -t "$SESSION"
    ;;
  list)
    tmux ls
    ;;
  kill)
    SESSION="${1:-$SESSION}"; tmux kill-session -t "$SESSION"
    ;;
  new)
    lang="${1:-:zsh}"; title="${2:-win$RANDOM}"
    session_exists "$SESSION" || tmux new-session -d -s "$SESSION" -n "zsh" zsh -l
    case "$lang" in
      :py|:python)  tmux new-window -t "$SESSION" -n "$title" 'python3 -q' ;;
      :js|:node)    tmux new-window -t "$SESSION" -n "$title" 'node' ;;
      :rb|:ruby)    tmux new-window -t "$SESSION" -n "$title" 'irb' ;;
      :lua)         tmux new-window -t "$SESSION" -n "$title" 'lua' ;;
      :bash)        tmux new-window -t "$SESSION" -n "$title" 'bash -l' ;;
      :zsh|:sh|*)   tmux new-window -t "$SESSION" -n "$title" 'zsh -l' ;;
    esac
    ;;
  run)
    lang="${1:-:zsh}"; shift || true
    code="$*"; title="${OMNITERM_TITLE:-job$RANDOM}"
    session_exists "$SESSION" || tmux new-session -d -s "$SESSION" -n "zsh" zsh -l
    tmux new-window -t "$SESSION" -n "$title" "poly $lang $code; echo; echo '[done] press Enter...'; read _"
    ;;
  theme)
    name="${1:-}"; [[ -z "$name" ]] && { print -u2 "Usage: omniterm theme <name>"; exit 2; }
    session_exists "$SESSION" || { print -u2 "Session not running: $SESSION"; exit 1; }
    apply_theme "$SESSION" "$name"
    ;;
  doctor)
    doctor
    ;;
  self-update)
    self_update "${1:-}"
    ;;
  snapshot)
    snapshot_save "${1:-$SESSION}" "${2:-default}"
    ;;
  restore)
    snapshot_restore "${1:-$SESSION}" "${2:-default}"
    ;;
  *)
    usage; exit 2 ;;
esac

# === speed-apt integration ===
have(){ command -v "$1" >/dev/null 2>&1; }

speed_apt_install() {
  sudo apt update
  sudo apt install -y aria2 curl
  /bin/bash -c "$(curl -sL https://git.io/vokNn)"   # apt-fast quick install
  sudo sed -i \
    -e "s|^#\?MIRRORS=.*|MIRRORS=( 'http://http.kali.org/kali' )|" \
    -e "s/^#\?_MAXNUM=.*/_MAXNUM=16/" \
    -e "s/^#\?_MAXCONPERSRV=.*/_MAXCONPERSRV=10/" \
    -e "s/^#\?_SPLITCON=.*/_SPLITCON=8/" \
    -e "s/^#\?_MINSPLITSZ=.*/_MINSPLITSZ=5M/" \
    /etc/apt-fast.conf 2>/dev/null || true
  echo "[speed-apt] apt-fast installed & configured."
}

speed_apt_on() {
  if ! grep -q 'alias au=' "$HOME/.zshrc" 2>/dev/null; then
    printf "%s\n" 'alias au="sudo apt-fast update && sudo apt-fast full-upgrade -y && sudo apt-fast autoremove --purge -y && sudo apt-fast autoclean"' >> "$HOME/.zshrc"
  else
    sed -i 's|^alias au=.*|alias au="sudo apt-fast update && sudo apt-fast full-upgrade -y && sudo apt-fast autoremove --purge -y && sudo apt-fast autoclean"|' "$HOME/.zshrc"
  fi
  echo "[speed-apt] enabled. Reload shell (exec zsh -l) to use au."
}

speed_apt_off() {
  sed -i 's|^alias au=.*|alias au="sudo apt update && sudo apt full-upgrade -y && sudo apt autoremove --purge -y && sudo apt autoclean"|' "$HOME/.zshrc" 2>/dev/null || true
  echo "[speed-apt] disabled. Reload shell to apply."
}

speed_apt_test() {
  if command -v apt-fast >/dev/null 2>&1; then
    echo "[speed-apt] apt-fast: $(apt-fast --version 2>/dev/null | head -n1)"
    echo "[speed-apt] running update (may show debug lines)…"
    sudo apt-fast -o Debug::NoLocking=1 -o Debug::pkgAcquire::Worker=1 update || true
  else
    echo "[-] apt-fast not found. Run: omniterm speed-apt install"
    return 1
  fi
}

# === version management ===
version_file(){ print -- "${OMNITERM_VERSION_FILE:-$HOME/kydras-omniterm/VERSION}"; }
version_show(){
  local vf; vf="$(version_file)"
  [[ -r "$vf" ]] && cat "$vf" || echo "unknown"
}
version_bump(){
  local kind="patch" msg="" repo="$HOME/kydras-omniterm"
  while [[ "${1:-}" == --* ]]; do
    case "$1" in
      --major|--minor|--patch) kind="${1#--}";;
      --repo) shift; repo="${1:-$repo}";;
      *) break;;
    esac; shift || true
  done
  msg="${*:-}"
  [[ -d "$repo/.git" ]] || { echo "[-] not a git repo: $repo"; return 2; }
  local vf; vf="$(version_file)"
  local v="0.0.0"; [[ -r "$vf" ]] && v="$(<"$vf")"
  local M m p; IFS=. read -r M m p <<< "$v"
  : "${M:=0}" "${m:=0}" "${p:=0}"
  case "$kind" in
    major) ((M+=1,m=0,p=0));;
    minor) ((m+=1,p=0));;
    patch) ((p+=1));;
  esac
  local nv="${M}.${m}.${p}"
  print -- "$nv" > "$vf"
  ( cd "$repo"
    git add "$(realpath --relative-to="$repo" "$vf")" || git add VERSION
    git commit -m "${msg:-chore(version): bump to v$nv}"
    git tag "v$nv" -m "v$nv"
    git push && git push --tags
  )
  echo "[version] now $nv"
}

# === modern APT (Nala) + fast mirror picker ===

have(){ command -v "$1" >/dev/null 2>&1; }

enable_parallel_apt() {
  # Prefer parallel queueing per host (safe for apt & nala)
  local cfg="/etc/apt/apt.conf.d/90omniterm-parallel"
  sudo bash -lc "cat > '$cfg' <<'C'
Acquire::Queue-Mode "host";
Acquire::Retries "3";
C"
  echo "[mirrors] enabled parallel APT in $cfg"
}

install_nala() {
  sudo apt update
  sudo apt install -y nala
  echo "[mirrors] nala installed: $(nala --version 2>/dev/null | head -n1)"
}

# Switch your 'au' maintenance alias to use nala (instead of apt/apt-fast)
speed_apt_use_nala() {
  if ! grep -q 'alias au=' "$HOME/.zshrc" 2>/dev/null; then
    printf "%s\n" 'alias au="sudo nala update && sudo nala upgrade -y && sudo nala autoremove -y && sudo nala clean"' >> "$HOME/.zshrc"
  else
    sed -i 's|^alias au=.*|alias au="sudo nala update && sudo nala upgrade -y && sudo nala autoremove -y && sudo nala clean"|' "$HOME/.zshrc"
  fi
  echo "[mirrors] set 'au' to use nala. Reload shell (exec zsh -l) to apply."
}

# Extract base URLs (column 2) from a sources.list file
_extract_urls() {
  awk '$1 ~ /^deb/ {print $2}' "$1" | sed 's|/*$||' | sort -u
}

# Benchmark a list of base URLs by timing a small index fetch
_bench_urls() {
  local urls=("$@")
  local tmp; tmp="$(mktemp)"
  for u in "${urls[@]}"; do
    # choose a small, commonly present file; fallbacks for Debian/Kali
    for path in "dists/kali-rolling/InRelease" "dists/stable/InRelease" "dists/bookworm/InRelease"; do
      if curl -m 6 -fsSL -o /dev/null -w "%{time_total}\t$u/$path\n" "$u/$path" 2>/dev/null; then
        break
      fi
    done
  done | sort -n > "$tmp"
  cat "$tmp"
  rm -f "$tmp"
}

# Update apt-fast.conf MIRRORS=( 'url1' 'url2' ... )
_update_aptfast_mirrors() {
  local urls=("$@")
  [[ ${#urls[@]} -eq 0 ]] && { echo "[mirrors] no URLs to write into apt-fast.conf"; return 0; }
  local conf="/etc/apt-fast.conf"
  local joined=""
  # quote each url for zsh-safe eval
  for u in "${urls[@]}"; do joined="$joined '$u'"; done
  sudo bash -lc "
    if [[ -f '$conf' ]]; then
      if grep -q '^MIRRORS=' '$conf'; then
        sed -i \"s|^MIRRORS=.*|MIRRORS=(${joined# })|\" '$conf'
      else
        printf '\nMIRRORS=(%s)\n' \"$joined\" >> '$conf'
      fi
    fi
  "
  echo "[mirrors] wrote top mirrors to $conf"
}

mirrors_auto() {
  enable_parallel_apt
  have nala || install_nala

  echo "[mirrors] running: sudo nala fetch --auto -y"
  # Let nala generate a tuned sources file (non-interactive)
  # It usually writes a *nala*.list; we’ll search for it.
  sudo nala fetch --auto -y || true

  local sfile=""
  for guess in /etc/apt/sources.list.d/*nala*.list /etc/apt/sources.list.d/nala/*.list /etc/apt/sources.list; do
    [[ -r "$guess" ]] && { sfile="$guess"; break; }
  done
  [[ -z "$sfile" ]] && { echo "[-] could not find a sources.list after nala fetch"; return 2; }

  echo "[mirrors] using sources from: $sfile"
  local urls=(); urls=("${(@f)$(_extract_urls "$sfile")}")
  [[ ${#urls[@]} -eq 0 ]] && { echo "[-] no URLs found in $sfile"; return 2; }

  echo "[mirrors] benchmarking ${#urls[@]} candidate mirrors..."
  local ranked; ranked="$(_bench_urls ${urls[@]})"
  print -- "$ranked" | head -n 10

  # Take top 4 URLs from the benchmark output
  local best=()
  local i=0
  while IFS=$'\t' read -r secs full; do
    # cut base (strip the "/dists/...") — we printed "$u/$path"; base is before /dists
    local base="${full%%/dists/*}"
    [[ -n "$base" ]] && best+="$base"
    (( ++i >= 4 )) && break
  done <<< "$ranked"

  # De-dup
  local uniq=("${(@u)best}")

  # Update apt-fast.conf mirrors to match the winners (if apt-fast is installed)
  if have apt-fast; then
    _update_aptfast_mirrors "${uniq[@]}"
  fi

  # Final update so APT/Nala use the tuned list immediately
  sudo apt update || true
  echo "[mirrors] done."
}


# === asciinema recording ===
have(){ command -v "$1" >/dev/null 2>&1; }

record_start() {
  have asciinema || { echo "[-] install asciinema: sudo apt install -y asciinema"; return 127; }
  local dir="${OMNITERM_REC_DIR:-$HOME/kydras-omniterm/.casts}"
  mkdir -p "$dir"
  local file="$dir/${OMNITERM_SESSION:-k-omni}-$(date +%Y%m%d-%H%M%S).cast"
  tmux display-message "Recording to $file (Ctrl-D in this pane to stop)"
  tmux send-keys "asciinema rec -q '$file'" C-m
}

record_stop() {
  # sends EOF to the active pane; asciinema stops on EOF
  tmux send-keys C-d
}

record_play() {
  local file="${1:-}"
  local dir="${OMNITERM_REC_DIR:-$HOME/kydras-omniterm/.casts}"
  [[ -n "$file" ]] || file="$(ls -1t "$dir"/*.cast 2>/dev/null | head -n1 || true)"
  [[ -r "$file" ]] || { echo "[-] no cast found in $dir"; return 2; }
  asciinema play "$file"
}

# === simple job queue ===
_queue_dir(){ print -- "${OMNITERM_QUEUE_DIR:-$HOME/kydras-omniterm/.queue}"; }

queue_add() {
  local lang="${1:-:zsh}"; shift || true
  [[ "$lang" == :* ]] || { echo "Usage: omniterm queue add :lang 'code' [--title t] [--notify]"; return 2; }
  local title="job$RANDOM" notify=0
  # parse optional flags at the end
  local args=("$@")
  for i in {1..${#args[@]}}; do
    case "${args[$i]:-}" in
      --title) ((i++)); title="${args[$i]:-$title}" ;;
      --notify) notify=1 ;;
    esac
  done
  local code="$*"
  local q="$(_queue_dir)"; mkdir -p "$q"
  local fn="$q/$(date +%s)-$RANDOM.job"
  {
    echo "lang='$lang'"
    echo "title='${title//\'/}'"
    echo "notify='$notify'"
    echo "code='${code//\'/}'"
  } > "$fn"
  echo "[queue] added -> $fn"
}

queue_list() {
  local q="$(_queue_dir)"; mkdir -p "$q"
  ls -1t "$q"/*.job 2>/dev/null || echo "[queue] (empty)"
}

queue_clear() {
  local q="$(_queue_dir)"
  rm -f "$q"/*.job 2>/dev/null || true
  echo "[queue] cleared"
}

queue_run() {
  local q="$(_queue_dir)"; mkdir -p "$q"
  local sess="${OMNITERM_SESSION:-k-omni}"
  tmux has-session -t "$sess" 2>/dev/null || tmux new-session -d -s "$sess" -n zsh zsh -l
  # dedicated runner window that loops
  tmux new-window -t "$sess" -n "queue" "bash -lc '
    Q=\"$q\"
    echo \"[queue] watching \$Q (Ctrl-C to stop)\"
    while true; do
      for f in \$(ls -1 \"\$Q\"/*.job 2>/dev/null); do
        echo \"[queue] running \$f\"
        . \"\$f\"
        poly \"\$lang\" \"\$code\"
        st=\$?
        if [[ \"\$notify\" == 1 ]]; then
          command -v notify-send >/dev/null 2>&1 && notify-send \"omniterm queue\" \"\$title exited \$st\" || printf \"\a\"
        fi
        rm -f \"\$f\"
      done
      sleep 2
    done
  '"
}


# === direnv integration ===
have(){ command -v "$1" >/dev/null 2>&1; }

direnv_on() {
  have direnv || { echo "[-] install direnv first: sudo apt install -y direnv"; return 127; }
  if ! grep -q 'direnv hook zsh' "$HOME/.zshrc" 2>/dev/null; then
    printf '\n# direnv\nif command -v direnv >/dev/null 2>&1; then eval "$(direnv hook zsh)"; fi\n' >> "$HOME/.zshrc"
    echo "[direnv] hook added to ~/.zshrc (restart shell)"
  else
    echo "[direnv] hook already present"
  fi
  echo "[direnv] tip: create .envrc in your project; run: direnv allow"
}

direnv_off() {
  sed -i '/direnv hook zsh/d' "$HOME/.zshrc" 2>/dev/null || true
  echo "[direnv] hook removed from ~/.zshrc (restart shell)"
}

direnv_allow() { (cd "${1:-$PWD}" && direnv allow); }
direnv_deny()  { (cd "${1:-$PWD}" && direnv deny); }
direnv_reload(){ direnv reload; }

# === OpSec mode ===
opsec_apply_tmux() {
  # tmux-side hardening (no scrollback, no clipboard, clear history)
  tmux set -g history-limit 0       2>/dev/null || true
  tmux set -g message-limit 0       2>/dev/null || true
  tmux set -g set-clipboard off     2>/dev/null || true
  tmux setw -g monitor-activity off 2>/dev/null || true
  # purge current scrollback across panes
  tmux list-panes -a -F '#{pane_id}' 2>/dev/null | xargs -r -n1 tmux clear-history -t
}

opsec_relax_tmux() {
  # sensible defaults back on
  tmux set -g history-limit 2000    2>/dev/null || true
  tmux set -g message-limit 100     2>/dev/null || true
  tmux set -g set-clipboard on      2>/dev/null || true
}

opsec_on() {
  export OMNITERM_OPSEC=1
  tmux set-environment -g OMNITERM_OPSEC 1 2>/dev/null || true
  opsec_apply_tmux
  echo "[opsec] enabled (history disabled in new panes; tmux hardened)"
}

opsec_off() {
  unset OMNITERM_OPSEC
  tmux set-environment -gu OMNITERM_OPSEC 2>/dev/null || true
  opsec_relax_tmux
  echo "[opsec] disabled"
}

opsec_status() {
  if [[ "${OMNITERM_OPSEC:-0}" = 1 ]]; then
    echo "[opsec] ON"
  else
    echo "[opsec] OFF"
  fi
}


# === docs helper (snippets → README) ===
_docs_repo() { print -- "${OMNITERM_REPO:-$HOME/kydras-omniterm}"; }
_docs_dir()  { print -- "$(_docs_repo)/docs/snippets"; }
_docs_target(){ print -- "$(_docs_repo)/README.md"; }

docs_list() {
  local d; d="$(_docs_dir)"; mkdir -p "$d"
  ls -1 "$d"/*.md 2>/dev/null | sed "s#.*/##; s#\.md$##" || echo "(no snippets yet)"
}
docs_show() {
  local s="${1:-}"; [[ -z "$s" ]] && { echo "Usage: omniterm docs show <section>"; return 2; }
  local f="$(_docs_dir)/${s}.md"
  [[ -r "$f" ]] || { echo "[-] snippet not found: $s"; docs_list; return 2; }
  cat "$f"
}
docs_add() {
  local s="${1:-}"; shift || true
  [[ -z "$s" ]] && { echo "Usage: omniterm docs add <section> [--after '### Heading'|--top|--bottom]"; return 2; }
  local repo="$(_docs_repo)" d="$(_docs_dir)" readme="$(_docs_target)"
  local src="$d/${s}.md" where="bottom" after=""
  while [[ "${1:-}" == --* ]]; do
    case "$1" in
      --repo) shift; repo="${1:-$repo}"; d="$repo/docs/snippets"; readme="$repo/README.md" ;;
      --after) shift; after="${1:-}"; where="after" ;;
      --top) where="top" ;;
      --bottom) where="bottom" ;;
      *) break ;;
    esac; shift || true
  done
  [[ -r "$src" ]] || { echo "[-] snippet not found: $s"; docs_list; return 2; }
  mkdir -p "$repo"; : > "$readme" 2>/dev/null || true
  local marker="<!-- OT:section:${s} -->"
  if grep -qF "$marker" "$readme" 2>/dev/null; then
    echo "[docs] section '${s}' already present in README.md"; return 0
  fi
  local tmp; tmp="$(mktemp)"
  { print -- "$marker"; print; cat "$src"; print; } > "$tmp"
  case "$where" in
    top)     { cat "$tmp"; cat "$readme" 2>/dev/null; } > "${readme}.new" ;;
    after)
      if [[ -n "$after" ]] && grep -n "^${after}$" "$readme" >/dev/null 2>&1; then
        awk -v insf="$tmp" -v h="$after" '
          {print}
          $0==h && !done {print ""; while((getline l < insf)>0) print l; print ""; done=1}
        ' "$readme" > "${readme}.new"
      else
        { cat "$readme" 2>/dev/null; cat "$tmp"; } > "${readme}.new"
      fi
      ;;
    bottom|*){ cat "$readme" 2>/dev/null; cat "$tmp"; } > "${readme}.new" ;;
  esac
  mv "${readme}.new" "$readme"
  echo "[docs] added '${s}' to $readme"
}
